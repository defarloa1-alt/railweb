/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/main.ts
__export(exports, {
  YAMLTableSettingTab: () => YAMLTableSettingTab,
  default: () => YAMLTablePlugin
});
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  language: "yaml-table"
};
var YAMLTablePlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerMarkdownCodeBlockProcessor(this.settings.language, this.yamlTableProcessor.bind(this));
    this.addSettingTab(new YAMLTableSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async yamlTableProcessor(source, el, ctx) {
    let captionText = null;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (view) {
      const sectionInfo = ctx.getSectionInfo(el);
      if (sectionInfo) {
        const langLine = view.editor.getLine(sectionInfo.lineStart);
        const langPattern = new RegExp("^```\\s*" + this.settings.language + ":\\s*(.+)");
        const match = langLine.match(langPattern);
        if (match && match[1]) {
          captionText = match[1].trim();
        }
      }
    }
    try {
      el.empty();
      if (captionText) {
        const captionEl = document.createElement("div");
        captionEl.className = "yaml-table-caption";
        captionEl.textContent = captionText;
        el.appendChild(captionEl);
      }
      const data = (0, import_obsidian.parseYaml)(source);
      let renderedElement = null;
      if (Array.isArray(data)) {
        renderedElement = await this.createHTMLElementForArray(data, ctx.sourcePath, this);
      } else if (data !== null && typeof data === "object") {
        renderedElement = await this.createTableFromObject(data, ctx.sourcePath, this);
      }
      if (renderedElement instanceof HTMLTableElement) {
        renderedElement.classList.add("yaml-table");
      }
      if (renderedElement) {
        const containerEl = document.createElement("div");
        containerEl.className = "yaml-table-container";
        containerEl.appendChild(renderedElement);
        el.appendChild(containerEl);
        containerEl.addEventListener("click", (event) => {
          var _a;
          const view2 = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
          if (view2) {
            const pos = (_a = ctx.getSectionInfo(el)) == null ? void 0 : _a.lineStart;
            if (pos !== void 0) {
              view2.editor.setCursor(pos);
              view2.editor.focus();
            }
          }
        });
      } else {
        const infoDiv = document.createElement("div");
        infoDiv.textContent = "No data to display or unsupported data type.";
        infoDiv.className = "yaml-table-info";
        el.appendChild(infoDiv);
      }
    } catch (e) {
      const errorDiv = document.createElement("div");
      if (e instanceof Error) {
        errorDiv.textContent = `YAML parsing error: ${e.message}`;
      } else {
        errorDiv.textContent = `An unknown error occurred during YAML processing.`;
      }
      errorDiv.className = "yaml-table-error";
      el.appendChild(errorDiv);
    }
  }
  async createTableFromObject(data, sourcePath, component) {
    if (Object.keys(data).length === 0) {
      return null;
    }
    const table = document.createElement("table");
    const tbody = table.createTBody();
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        const row = tbody.insertRow();
        const keyCell = document.createElement("th");
        keyCell.setAttribute("scope", "row");
        await import_obsidian.MarkdownRenderer.render(this.app, String(key), keyCell, sourcePath, component);
        row.appendChild(keyCell);
        const valueCell = row.insertCell();
        await this.renderValue(data[key], valueCell, sourcePath, component);
      }
    }
    return table;
  }
  async createHTMLElementForArray(data, sourcePath, component) {
    if (data.length === 0) {
      return null;
    }
    const firstItem = data[0];
    const isObjectArray = firstItem !== null && typeof firstItem === "object" && !Array.isArray(firstItem);
    if (isObjectArray) {
      const table = document.createElement("table");
      const keys = new Set();
      data.forEach((item) => {
        if (typeof item === "object" && item !== null) {
          Object.keys(item).forEach((key) => keys.add(key));
        }
      });
      if (keys.size === 0)
        return null;
      const thead = table.createTHead();
      const headerRow = thead.insertRow();
      for (const key of keys) {
        const th = document.createElement("th");
        await import_obsidian.MarkdownRenderer.render(this.app, String(key), th, sourcePath, component);
        headerRow.appendChild(th);
      }
      const tbody = table.createTBody();
      for (const item of data) {
        if (typeof item === "object" && item !== null) {
          const row = tbody.insertRow();
          const itemRecord = item;
          for (const key of keys) {
            const cell = row.insertCell();
            if (Object.prototype.hasOwnProperty.call(itemRecord, key)) {
              await this.renderValue(itemRecord[key], cell, sourcePath, component);
            } else {
              cell.textContent = "";
            }
          }
        }
      }
      return table;
    } else {
      const list = document.createElement("ul");
      for (const item of data) {
        const li = document.createElement("li");
        await this.renderValue(item, li, sourcePath, component);
        list.appendChild(li);
      }
      return list;
    }
  }
  async renderValue(value, container, sourcePath, component) {
    if (Array.isArray(value) && value.length === 1 && Array.isArray(value[0]) && value[0].length === 1 && typeof value[0][0] === "string") {
      const linkText = value[0][0];
      const markdownString = `[[${linkText}]]`;
      await import_obsidian.MarkdownRenderer.render(this.app, markdownString, container, sourcePath, component);
      return;
    }
    if (value === null || value === void 0) {
      container.textContent = "";
    } else if (Array.isArray(value)) {
      const nestedElement = await this.createHTMLElementForArray(value, sourcePath, component);
      if (nestedElement) {
        container.appendChild(nestedElement);
      } else {
        container.textContent = "(empty array)";
      }
    } else if (typeof value === "object" && value !== null) {
      const nestedTable = await this.createTableFromObject(value, sourcePath, component);
      if (nestedTable) {
        container.appendChild(nestedTable);
      } else {
        container.textContent = "(empty object)";
      }
    } else {
      let markdownString = String(value);
      if (typeof value === "string") {
        if (value.startsWith("[[") && value.endsWith("]]")) {
        } else {
          const listItemMatch = value.match(/^\s*([-*+])\s+(.*)$/);
          if (listItemMatch && !value.includes("\\n")) {
            markdownString = listItemMatch[2];
          }
        }
      }
      await import_obsidian.MarkdownRenderer.render(this.app, markdownString, container, sourcePath, component);
    }
  }
};
var YAMLTableSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Default Language Name").setDesc("Language identifier for YAML code blocks to be rendered as tables").addText((text) => text.setPlaceholder("yaml-table").setValue(this.plugin.settings.language).onChange(async (value) => {
      if (value.trim()) {
        this.plugin.settings.language = value.trim();
        await this.plugin.saveSettings();
      }
    }));
  }
};

/* nosourcemap */