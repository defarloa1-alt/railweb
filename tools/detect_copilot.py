"""Detect likely Copilot/assistant-generated content in files or text.

This is a lightweight heuristic scanner intended for CI warning/labeling.
It searches for configurable regex patterns in files or stdin and emits a
JSON report to stdout. Exit code is 0 if no matches, 1 if matches found.
"""
from __future__ import annotations

import argparse
import json
import re
import sys
from pathlib import Path
from typing import List, Dict


DEFAULT_PATTERNS = [
    r"\bcopilot\b",
    r"generated by (github )?copilot",
    r"generated by assistant",
    r"assistant-generated",
    r"co-authored-by:\s*",
]


def compile_patterns(patterns: List[str]) -> List[re.Pattern]:
    return [re.compile(p, re.IGNORECASE) for p in patterns]


def scan_text(text: str, patterns: List[re.Pattern]) -> List[Dict]:
    hits = []
    for i, line in enumerate(text.splitlines(), start=1):
        for p in patterns:
            if p.search(line):
                hits.append({"line": i, "text": line.strip(), "pattern": p.pattern})
    return hits


def scan_path(path: Path, patterns: List[re.Pattern]) -> Dict:
    try:
        text = path.read_text(encoding="utf-8")
    except Exception as e:
        return {"path": str(path), "error": str(e), "matches": []}
    return {"path": str(path), "matches": scan_text(text, patterns)}


def main(argv: List[str] | None = None) -> int:
    p = argparse.ArgumentParser(description="Detect Copilot/assistant markers in files or stdin")
    p.add_argument("paths", nargs="*", help="Files or directories to scan. If empty, reads stdin.")
    p.add_argument("--pattern", "-p", action="append", help="Additional regex pattern to search for (case-insensitive).")
    p.add_argument("--json", dest="out_json", action="store_true", help="Output JSON report to stdout")
    args = p.parse_args(argv)

    patterns = DEFAULT_PATTERNS.copy()
    if args.pattern:
        patterns.extend(args.pattern)
    compiled = compile_patterns(patterns)

    report = {"matches": []}

    if not args.paths:
        text = sys.stdin.read()
        matches = scan_text(text, compiled)
        if matches:
            report["matches"].append({"path": "<stdin>", "matches": matches})
    else:
        for pth in args.paths:
            path = Path(pth)
            if path.is_dir():
                for f in path.rglob("*"):
                    if f.is_file():
                        res = scan_path(f, compiled)
                        if res.get("matches"):
                            report["matches"].append(res)
            elif path.is_file():
                res = scan_path(path, compiled)
                if res.get("matches"):
                    report["matches"].append(res)
            else:
                # path may be a glob or missing file
                continue

    if args.out_json:
        print(json.dumps(report, indent=2))
    else:
        if not report["matches"]:
            print("No copilot/assistant markers found.")
        else:
            for r in report["matches"]:
                print(f"Matches in {r.get('path')}:")
                for m in r.get("matches", []):
                    print(f"  {m['line']}: {m['text']}")

    return 1 if report["matches"] else 0


if __name__ == "__main__":
    raise SystemExit(main())
